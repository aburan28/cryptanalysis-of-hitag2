\chapter{Time-memory tradeoff}

\paragraph{Summary}


\section{Time-memory tradeoff attack}

A brute-force attack on a block cipher would be to try out all the possible keys that could be used to encrypt certain known (or chosen) or unknown plaintext. The key which decrypts the ciphertext to give the known plaintext or most sensible plaintext (if it is unknown) is then the original key. Though very simple in theory, brute-force attacks require a very long time to break ciphers in practice. There is no storage required during this attack, but the time required to break the cipher is very long. Though modern computers have advanced tremendously in their computational speed over the last some years, design of new ciphers have incorporated longer key sizes to protect against brute-force attacks, thus not making brute-forcing any practical.

For example, in order to break a 32 bit key, we would need to carry out $2^{32}$ computations on available ciphertext. Using a 2GHz processor (which is quite common today for personal use), we can run $2^{31}$ clock cycles in one second. Since one encryption would take a fixed number of clock cycles, say a modest $2^2$ cycles, by simple calculation, we can have a brute-force attack on the cipher in $2^3$ seconds, or 8 seconds. As can be seen, this is a dismally weak key size. For a key size of 48 bits, the brute-force would take $2^{19}$ seconds which is 524288 seconds, or just more than 6 days. In modern ciphers, the key sizes starting from 128 bits in length are considered safe. AES uses a minimum key size of 128 bits, which can be extended to use 256 bits. 

Brute-force attacks are just one side of the coin. The other way of breaking a cipher in a known (or chosen) plaintext attack is to precompute ciphertexts corresponding to all the possible keys and to store the (key, ciphertext) pair in a table in memory. During the attack, the attacker just needs to do a table lookup for the available ciphertext, and get the corresponding key. Again, the concept is quite straightforward theoretically, but it also faces the same problem as brute-force attacks, but from a different perspective. A table lookup takes constant time, so practically the attack time is very less. But, the amount of precomputed data is tremendous and the attacker would need very large amount of memory to save this data for the attack phase. 

Let us take the weaker case of a 32 bit key, which is far from use in today's ciphers. For each of $2^{32}$ possible keys, we need to store 32 bits of key and 32 bits of ciphertext (assuming the plaintext is 32 bits, which could very well be more). This amounts to 64 bits or 8 bytes of data for every possible key. $2^{32}$ such entries would require $2^{32}$ * 8 bytes which is 32 gigabytes. For a random access memory, 32 GB is a high requirement. For higher key sizes, this requirement gets impossible to even think of.

The technique of time-memory tradeoff is a way between the above two extreme and practically difficult ideas. TMTO solves our problem by using memory in order to reduce the time taken for attack. As a result, with considerable precomputation, the attack time can be reduced and thus the computational resources required. It brings both the parameters, time and memory, within reachable domains. Before we go into more details of the working of time-memory tradeoff attacks on ciphers, we would take a simple example of a general application of such tradeoffs.

\paragraph{Simple example of time-memory tradeoff:} Consider the problem of finding the number of \textbf{1}'s in the binary expansion of a non-negative integer $x$. The simplest algorithm to solve this problem would over 32 operations, shift the integer rightwards by one bit (except for the first operation) and add the values of all the least significant bits. The sum would then be the \emph{result}. The pseudo-code for this is:

\begin{verbatim}
// ones_count(x)
t = 0
for i = 0 to len(x) - 1
    t = t + (x >> i) & 1
next i
return t
\end{verbatim}

Here, $>>$ denotes the right shift operation and \& denotes bitwise AND operation. This algorithm performs 32 operations (which is based on the number of times it loops) and has nearly no memory requirement. The other approach to solve this problem would be to store the required \emph{result} for each of the possible $2^{32}$ integers in memory. This way, just one memory lookup is required to find the result for $x$. While we need to have a memory of the order of $2^{32}$. One middle way between both these approaches would be to store the \textit{result} for all possible 8 bit numbers, rather than doing it for all 32 bit numbers. Then the memory required would be of the order of $2^{8}$. We break the 32 bit integer into four bytes, and add the stored \textit{result} for each of the bytes, by looking up in the table. If $y_1$, $y_2$, $y_3$ and $y_4$ are the four bytes, such that $y_4$ = ($x$ $\&$ $0$x$FF$), $y_3$ = ($(x >> 8)$ $\&$ $0$x$FF$), $y_2$ = ($(x >> 8)$ $\&$ $0$x$FF$) and $y_1$ = ($(x >> 8)$ $\&$ $0$x$FF$), and if p is the array which stores the \textit{result} for all possible bytes, then the \textit{result} for $x$ can simply be calculated by

\begin{verbatim}
t = p[y1] + p[y2] + p[y3] + p[y4]
\end{verbatim}

The number of operations in this case is 4, as the pre-computed table is looked up four times. This is just one way of realizing a middle way in between the extreme cases of time and memory. If the algorithm stores 4 bit values, with their corresponding \textit{result}, then the number of operations would be 8. Hence a optimum combination of memory and time can be selected depending on the resources at hand. 

\section{Birthday paradox}
% what the simple birthday paradox is %

% generalize it in terms of n %

% introduce birthday attack, define scenario (then take hash as example) %

% what is the variant of birthday paradox %

% meet in the middle attack on DES by diffie hellman %
% meet in the middle attack is a TMTO attack, which uses the variant of borthday paradox %
% a TMTO attack would always use variant of birthday attack %

\section{Simple TMTO attack on stream ciphers}

\section{Simple TMTO for HiTag2}

\section{Another TMTO for HiTag2}

